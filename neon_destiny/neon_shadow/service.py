import uuid
from typing import List, Optional, Dict, Any, Callable
import random

from neon_shadow.ui import display_notification


class CloudService:
    """Represents an AWS service that can be deployed by the player."""

    def __init__(self, name: str, description: str, service_type: str,
                 cost_per_hour: float, deploy_cost: int,
                 region_availability: List[str],
                 dependencies: Optional[List[str]] = None) -> None:
        """Initialize a new cloud service.
        
        Args:
            name: Name of the service
            description: Description of what the service does
            service_type: Type of service (e.g., 'Compute', 'Storage', 'Database')
            cost_per_hour: Hourly cost to operate this service
            deploy_cost: One-time cost to deploy this service
            region_availability: List of AWS regions this service is available in
            dependencies: List of services required before this one can be deployed
        """
        self.name = name
        self.description = description
        self.service_type = service_type
        self.cost_per_hour = cost_per_hour
        self.deploy_cost = deploy_cost
        self.region_availability = region_availability
        self.dependencies = dependencies if dependencies else []
        self.is_deployed = False
        self.deployment_region = None
        self.health = 100  # Health of the service
        self.security_level = 1  # Security level (1-10)
        self.performance = 5  # Performance level (1-10)
        self.revenue_per_hour = cost_per_hour * 1.5  # Base revenue
        self.instance_id = str(uuid.uuid4())[:8]  # Generate unique instance ID
        self.uptime_days = 0  # Track how long service has been running
        self.last_maintenance = 0  # Day of last maintenance
        self.incident_history = []  # Track past incidents
        self.status_effects = []  # List of active effects on the service

    def __str__(self) -> str:
        """String representation of the service."""
        status = "DEPLOYED" if self.is_deployed else "NOT DEPLOYED"
        return f"{self.name} ({self.service_type}) - {status}"

    def deploy(self, region: str) -> bool:
        """Deploy the service to a region.
        
        Args:
            region: AWS region to deploy to
            
        Returns:
            True if deployment successful, False otherwise
        """
        if region in self.region_availability:
            self.is_deployed = True
            self.deployment_region = region
            self.uptime_days = 0
            display_notification(
                f"Deployed {self.name} to {region}", "success")
            return True
        else:
            display_notification(
                f"{self.name} not available in {region}", "error")
            return False

    def undeploy(self) -> bool:
        """Undeploy the service.
        
        Returns:
            True if service was undeployed, False if already not deployed
        """
        if self.is_deployed:
            self.is_deployed = False
            self.deployment_region = None
            display_notification(f"Undeployed {self.name}", "info")
            return True
        return False

    def calculate_revenue(self) -> float:
        """Calculate revenue generated by this service.
        
        Returns:
            Hourly revenue generated by this service
        """
        if not self.is_deployed:
            return 0

        # Base revenue
        revenue = self.revenue_per_hour

        # Adjust for performance and security
        performance_multiplier = 0.8 + (self.performance / 10) * 0.4
        security_multiplier = 0.9 + (self.security_level / 10) * 0.2

        # Health affects revenue
        health_penalty = 1 - ((100 - self.health) / 100) * 0.5

        # Apply uptime bonus - services become more valuable as they remain stable
        uptime_bonus = min(1.5, 1 + (self.uptime_days / 100))

        return revenue * performance_multiplier * security_multiplier * health_penalty * uptime_bonus

    def apply_damage(self, amount: int) -> bool:
        """Apply damage to the service.
        
        Args:
            amount: Amount of damage to apply
            
        Returns:
            True if service has failed (health reached 0), False otherwise
        """
        self.health = max(0, self.health - amount)
        if self.health == 0:
            self.is_deployed = False
            display_notification(
                f"{self.name} has failed and is now offline!", "error")
            self.incident_history.append({
                "type": "failure",
                "amount": amount,
                "day": self.uptime_days
            })
            return True  # Indicate service failure

        # Record incident
        self.incident_history.append({
            "type": "damage",
            "amount": amount,
            "day": self.uptime_days
        })
        return False  # Service still operational

    def repair(self, amount: int) -> int:
        """Repair the service.
        
        Args:
            amount: Amount of health to restore
            
        Returns:
            Actual amount of health restored
        """
        old_health = self.health
        self.health = min(100, self.health + amount)
        self.last_maintenance = self.uptime_days
        display_notification(
            f"Repaired {self.name} (+{self.health - old_health} health)", "success")
        return self.health - old_health  # Return actual amount repaired

    def enhance_security(self, amount: int) -> int:
        """Enhance the security of the service.
        
        Args:
            amount: Amount to increase security level by
            
        Returns:
            Actual amount security level was increased by
        """
        old_security = self.security_level
        self.security_level = min(10, self.security_level + amount)
        display_notification(
            f"Enhanced {self.name} security (+{self.security_level - old_security})", "success")
        return self.security_level - old_security  # Return actual security increase

    def optimize_performance(self, amount: int) -> int:
        """Optimize the performance of the service.
        
        Args:
            amount: Amount to increase performance by
            
        Returns:
            Actual amount performance was increased by
        """
        old_performance = self.performance
        self.performance = min(10, self.performance + amount)
        display_notification(
            f"Optimized {self.name} performance (+{self.performance - old_performance})", "success")
        return self.performance - old_performance  # Return actual performance increase

    def add_status_effect(self, effect: Dict[str, Any]) -> None:
        """Add a temporary status effect to the service.
        
        Args:
            effect: Dictionary with effect details including 'name', 'duration',
                   and optional callback functions
        """
        self.status_effects.append(effect)
        display_notification(
            f"{self.name} is now affected by: {effect['name']}", "warning")

    def update_status_effects(self) -> None:
        """Update all status effects and remove expired ones."""
        active_effects = []
        for effect in self.status_effects:
            effect['duration'] -= 1
            if effect['duration'] > 0:
                active_effects.append(effect)
                # Apply ongoing effect
                if 'per_turn_effect' in effect and callable(effect['per_turn_effect']):
                    effect['per_turn_effect'](self)
            else:
                display_notification(
                    f"{effect['name']} effect has expired on {self.name}", "info")
                # Apply end effect if defined
                if 'end_effect' in effect and callable(effect['end_effect']):
                    effect['end_effect'](self)

        self.status_effects = active_effects
